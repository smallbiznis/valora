package service

import (
	"context"
	"testing"
	"time"

	"github.com/bwmarrin/snowflake"
	"github.com/glebarez/sqlite"
	billingcycledomain "github.com/smallbiznis/valora/internal/billingcycle/domain"
	invoicedomain "github.com/smallbiznis/valora/internal/invoice/domain"
	ratingdomain "github.com/smallbiznis/valora/internal/rating/domain"
	"github.com/stretchr/testify/assert"
	"go.uber.org/zap"
	"gorm.io/gorm"
)

func TestSnapshotInvoicing_StrictCompliance(t *testing.T) {
	// 1. Setup DB
	db, err := gorm.Open(sqlite.Open("file::memory:?cache=shared"), &gorm.Config{})
	assert.NoError(t, err)

	// Migrate relevant tables
	err = db.AutoMigrate(
		&ratingdomain.RatingResult{},
		&invoicedomain.Invoice{},
		&invoicedomain.InvoiceItem{},
		&invoicedomain.SubscriptionEntitlement{}, // The read-model struct
	)
	assert.NoError(t, err)

	node, _ := snowflake.NewNode(1)
	logger := zap.NewNop()

	// 2. Setup Service
	svcInterface := NewService(ServiceParam{
		DB:    db,
		Log:   logger,
		GenID: node,
	})

	svc, ok := svcInterface.(*Service)
	assert.True(t, ok)

	// We need to migrate billing_cycles too
	// InvoiceService uses billingcycledomain.BillingCycleStatus actually.
	// Let's just mock the DB data for `billing_cycles` table.
	// The service uses `billing_cycles` table.
	db.Exec("CREATE TABLE billing_cycles (id BIGINT, org_id BIGINT, subscription_id BIGINT, period_start DATETIME, period_end DATETIME, status TEXT)")

	// 3. Seed Data
	orgID := node.Generate()
	subID := node.Generate()
	cycleID := node.Generate()
	// invoiceID generated by service

	now := time.Now().UTC()
	start := now.Add(-30 * time.Hour * 24)
	end := now

	// Seed Cycle
	db.Exec("INSERT INTO billing_cycles (id, org_id, subscription_id, period_start, period_end, status) VALUES (?, ?, ?, ?, ?, ?)",
		cycleID, orgID, subID, start, end, "closing") // Status irrelevant for internal logic? GenerateInvoice checks status?
	// GenerateInvoice usually called by workflow when status is closing?
	// Service `GenerateInvoice(ctx, cycleID)` -> Check `loadBillingCycle`.

	// Seed Rating Result with FeatureCode
	ratingID := node.Generate()
	priceID := node.Generate() // ID not in DB
	featureCode := "feature_snapshot"

	err = db.Create(&ratingdomain.RatingResult{
		ID:             ratingID,
		OrgID:          orgID,
		SubscriptionID: subID,
		BillingCycleID: cycleID,
		PriceID:        priceID,
		FeatureCode:    featureCode, // CRITICAL
		Source:         "usage",
		Quantity:       10,
		UnitPrice:      100,
		Amount:         1000,
		Currency:       "USD",
		PeriodStart:    start,
		PeriodEnd:      end,
		Checksum:       "checksum_1",
		CreatedAt:      now,
	}).Error
	assert.NoError(t, err)

	// Seed Entitlement (Snapshot)
	err = db.Create(&invoicedomain.SubscriptionEntitlement{
		ID:             node.Generate(),
		OrgID:          orgID,
		SubscriptionID: subID,
		FeatureCode:    featureCode,
		FeatureName:    "Snapshot Plan Name", // Check for THIS
		EffectiveFrom:  start.Add(-1 * time.Hour),
	}).Error
	assert.NoError(t, err)

	// 4. Run Test: Success Case
	// Bypass GenerateInvoice due to SQLite lacking "FOR UPDATE" support.
	// We invoke listInvoiceItemPartsFromRating directly.

	// Create Invoice Draft manually
	invoiceID := node.Generate()
	err = db.Create(&invoicedomain.Invoice{
		ID:             invoiceID,
		OrgID:          orgID,
		SubscriptionID: subID,
		BillingCycleID: cycleID,
		Status:         invoicedomain.InvoiceStatusDraft,
		CreatedAt:      now,
	}).Error
	assert.NoError(t, err)

	// Construct billing cycle row (private struct)
	cycle := billingCycleRow{
		ID:             cycleID,
		OrgID:          orgID,
		SubscriptionID: subID,
		PeriodStart:    start,
		PeriodEnd:      end,
		Status:         billingcycledomain.BillingCycleStatusClosing,
	}

	// Execute logic
	err = db.Transaction(func(tx *gorm.DB) error {
		return svc.listInvoiceItemPartsFromRating(context.Background(), tx, cycle, invoiceID)
	})
	assert.NoError(t, err)

	// 5. Verify Invoice Items
	var items []invoicedomain.InvoiceItem
	err = db.Where("invoice_id = ?", invoiceID).Find(&items).Error
	assert.NoError(t, err)
	if assert.Len(t, items, 1) {
		assert.Contains(t, items[0].Description, "Snapshot Plan Name")
		assert.Equal(t, int64(1000), items[0].Amount)
	}

	// Verify "prices" table was NOT used. We didn't even migrate it or seed it.

	// 6. Run Test: Failure Case (No Entitlement)
	// Create another rating result with unknown feature
	ratingID2 := node.Generate()
	unknownFeature := "feature_unknown"

	err = db.Create(&ratingdomain.RatingResult{
		ID:             ratingID2,
		OrgID:          orgID,
		SubscriptionID: subID,
		BillingCycleID: cycleID,
		PriceID:        priceID,
		FeatureCode:    unknownFeature, // No entitlement
		Source:         "usage",
		Quantity:       5,
		UnitPrice:      100,
		Amount:         500,
		Currency:       "USD",
		PeriodStart:    start,
		PeriodEnd:      end,
		Checksum:       "checksum_2",
		CreatedAt:      now,
	}).Error
	assert.NoError(t, err)

	// Generation should fail now
	err = db.Transaction(func(tx *gorm.DB) error {
		return svc.listInvoiceItemPartsFromRating(context.Background(), tx, cycle, invoiceID)
	})
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "no matching entitlement")
}
